"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[127],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=r,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return t?a.createElement(h,i(i({ref:n},p),{},{components:t})):a.createElement(h,i({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},1910:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},i=":floppy_disk: Memory",l={unversionedId:"C++/memory",id:"C++/memory",title:":floppy_disk: Memory",description:"[TOC]",source:"@site/docs/C++/memory.md",sourceDirName:"C++",slug:"/C++/memory",permalink:"/notes/C++/memory",draft:!1,editUrl:"https://github.com/hasauino/notes/edit/master/docs/C++/memory.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Essential Operations",permalink:"/notes/C++/essential_operations"},next:{title:"C++ Tips + Style",permalink:"/notes/C++/modern_cpp"}},s={},c=[{value:"Memory Types",id:"memory-types",level:2},{value:"Virtual Memory",id:"virtual-memory",level:2},{value:"Cache",id:"cache",level:2},{value:"Process Memory Model",id:"process-memory-model",level:2},{value:"<code>malloc</code>, <code>calloc</code>, <code>realloc</code>, and <code>free</code>",id:"malloc-calloc-realloc-and-free",level:2},{value:"<code>new</code> and <code>delete</code>",id:"new-and-delete",level:2},{value:"Overriding <code>new</code>/<code>delete</code> operators",id:"overriding-newdelete-operators",level:3},{value:"Valgrind",id:"valgrind",level:2}],p={toc:c};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"-memory"},"\ud83d\udcbe Memory"),(0,r.kt)("p",null,"[TOC]"),(0,r.kt)("h2",{id:"memory-types"},"Memory Types"),(0,r.kt)("p",null,"In computers, there are multiple types of memory. The following is a list of memory types ordered from closest/fastest to furthest/slowest:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"CPU registers."),(0,r.kt)("li",{parentName:"ol"},"L1 cache."),(0,r.kt)("li",{parentName:"ol"},"L2 cache."),(0,r.kt)("li",{parentName:"ol"},"L3 cache (facilitates the protocol used for caching in multi-core CPUs)."),(0,r.kt)("li",{parentName:"ol"},"RAM/ROM (not sure which one is faster)."),(0,r.kt)("li",{parentName:"ol"},"Hard disks (HDD, SDD)...etc")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CPU registers, the cache memory (L1-L3), are not directly accessible by the programmer."),(0,r.kt)("li",{parentName:"ul"},"A very important memory type, though not physical, is ",(0,r.kt)("strong",{parentName:"li"},"Virtual Memory"),".")),(0,r.kt)("h2",{id:"virtual-memory"},"Virtual Memory"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each program is mapped to a virtual memory space which is mapped to the physical memory (RAM, and also hard disk - swap)."),(0,r.kt)("li",{parentName:"ul"},"Physical memory is mainly the RAM (but it also include other device registers)."),(0,r.kt)("li",{parentName:"ul"},"So a program does not interact with the physical memory directly and does not use the physical addresses.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Why?")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To avoid having programs competing against same address space."),(0,r.kt)("li",{parentName:"ul"},"Solves the problem of fragmentation: allocating large chunks of memory when there is fragmentation could fail even when there is still free physical space."),(0,r.kt)("li",{parentName:"ul"},"each program now is not limited by the available free space in the RAM. Since virtual memory could be mapped to hard disk in case no available free space or in case of ",(0,r.kt)("strong",{parentName:"li"},"page fault")," (when there is less RAM available the largest addressable location in the memory).")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When the RAM is full, the operating system starts swapping: it moves a chunk of memory from the RAM to the hard disk. The swapped memory could be stored in a file (swap file), or a partition (swap partition). In Linux, you could check how much swap is used using these commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"free -h\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"swapon --show\n")),(0,r.kt)("h2",{id:"cache"},"Cache"),(0,r.kt)("p",null,"In CPUs, there is a caching mechanism which stores chunks of memory that is likely to be used for speeding up access to it. Cache memory is something the programmer does not have access to, but there are 2 things that should be kept in mind:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Temporal Locality"),": data that was accessed recently, will be more likely cached than data access earlier."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spacial Locality"),": data closer to recently accessed data is more likely to be cached.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C++"},'#include <chrono>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nvoid contigious(unsigned long rows, unsigned long cols) {\n    int* matrix = new int[rows * cols];\n\n    auto t_start = chrono::high_resolution_clock::now();\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            *(matrix + (i * cols + j)) = 1;\n        }\n    }\n    auto t_end = chrono::high_resolution_clock::now();\n    auto duration = t_end - t_start;\n    printf("contigious access duration: %ld\\n", duration.count());\n}\n\nvoid non_contigious(unsigned long rows, unsigned long cols) {\n    int* matrix = new int[rows * cols];\n\n    auto t_start = chrono::high_resolution_clock::now();\n    for (int j = 0; j < cols; j++) {\n        for (int i = 0; i < rows; i++) {\n            *(matrix + (i * cols + j)) = 1;\n        }\n    }\n    auto t_end = chrono::high_resolution_clock::now();\n    auto duration = t_end - t_start;\n    printf("non-contigious access duration: %ld\\n", duration.count());\n}\n\nint main(int argc, char** argv) {\n    contigious(10000, 10000);\n    non_contigious(10000, 10000);\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"process-memory-model"},"Process Memory Model"),(0,r.kt)("p",null,"Each process is given a virtual memory space by the operating system. It consists of the following sections:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"OS kernel."),(0,r.kt)("li",{parentName:"ol"},"Stack: Automatic variables in local scopes."),(0,r.kt)("li",{parentName:"ol"},"Heap: Dynamically allocated variables."),(0,r.kt)("li",{parentName:"ol"},"BSS: uninitialized static variables."),(0,r.kt)("li",{parentName:"ol"},"Data: explicitly initialized static variables"),(0,r.kt)("li",{parentName:"ol"},"Text: program code")),(0,r.kt)("p",null,"variables in sections 4 & 5 are allocated once at start and persist throughout the program lifetime. "),(0,r.kt)("h2",{id:"malloc-calloc-realloc-and-free"},(0,r.kt)("inlineCode",{parentName:"h2"},"malloc"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"calloc"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"realloc"),", and ",(0,r.kt)("inlineCode",{parentName:"h2"},"free")),(0,r.kt)("p",null,"These are functions which are part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"stdlib.h")," header file in C."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <cstdlib>\n#include <cstddef>\n#include <string>\n\nusing namespace std;\n\n// malloc & free\nvoid example_1(){\n    int* ptr = (int*)malloc(sizeof(int));\n    *ptr = 10;\n    free(ptr);\n}\n\n// calloc\nvoid example_2(){\n    size_t size{10};\n    int* ptr = (int*)calloc(size, sizeof(int));\n    for (int i=0; i<size; i++){\n        ptr[i] = 0;\n    }\n    free(ptr);\n}\n\n// array of custom type\nvoid example_3(){\n    struct Person{\n        string first_name;\n        string last_name;\n        float age;\n    };\n    \n    Person* students = (Person*) calloc(3, sizeof(Person));\n    students[0].first_name = "Hassan";\n    students[0].last_name = "Umari";\n    students[0].age = 33.0;\n}\n\n// realloc\nvoid example_4(){\n    int* ptr = (int*)malloc(sizeof(int));\n    int* ptr = (int*)realloc(ptr, 2*sizeof(int));\n    ptr[0] = 10;\n    ptr[1] = 100;\n    free(ptr);    \n}\n')),(0,r.kt)("h2",{id:"new-and-delete"},(0,r.kt)("inlineCode",{parentName:"h2"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"delete")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," operators are the C++ counter part of C  ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," functions. The following are the differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"delete")," are operators. They can be overloaded in classes unlike ",(0,r.kt)("inlineCode",{parentName:"li"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"free")," which are functions."),(0,r.kt)("li",{parentName:"ul"},"Instantiating an object with  ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," automatically calls the constructor. Similarly, with ",(0,r.kt)("inlineCode",{parentName:"li"},"delete")," , the destructor is automatically called."),(0,r.kt)("li",{parentName:"ul"},"type safety: ",(0,r.kt)("inlineCode",{parentName:"li"},"malloc")," returns a void pointer which needs to be cast into the appropriate type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <cstdio>\n#include <string>\n\nusing namespace std;\n\n// simple example\nvoid example_1() {\n    int* ptr = new int(10);\n    ptr[0] = 100;\n    delete ptr;\n}\n\n// array of simple types\nvoid example_2() {\n    int* ptr = new int[3];\n    ptr[0] = 1;\n    ptr[1] = 2;\n    ptr[2] = 3;\n    delete[] ptr;\n}\n\n// array of custom types\nvoid example_3() {\n\n    struct Person {\n        string name;\n        float age;\n    };\n\n    int count{10};\n    Person* people = new Person[count];\n\n    for (int i = 0; i < count; i++) {\n        people[i].name = "Hassan Umari";\n        people[i].age = 33.0;\n    }\n    delete[] people;\n}\n\n// placement new operator example\nvoid example_4() {\n\n    struct Person {\n        string name;\n        float age;\n\n        ~Person() { printf("Person destructor\\n"); }\n    };\n\n    Person* hassan = (Person*)malloc(sizeof(Person));\n    new (hassan) Person;\n    hassan->~Person();\n    free(hassan); // must use free in this case (cannot use delete). Hence the explicit call to the destructor \n}\n')),(0,r.kt)("h3",{id:"overriding-newdelete-operators"},"Overriding ",(0,r.kt)("inlineCode",{parentName:"h3"},"new"),"/",(0,r.kt)("inlineCode",{parentName:"h3"},"delete")," operators"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nclass MyClass {\n   public:\n    MyClass() { printf("Constructor..\\n"); }\n    ~MyClass() { printf("Destructor..\\n"); }\n\n    void* operator new(size_t size) {\n        printf("allocating memory..\\n");\n        return malloc(size);\n    }\n\n    void* operator new[](size_t size) {\n        printf("allocating memory..\\n");\n        return malloc(size);\n    }\n\n    void operator delete(void* ptr) {\n        printf("freeing memory..\\n");\n        free(ptr);\n    }\n\n    void operator delete[](void* ptr) {\n        printf("freeing memory..\\n");\n        free(ptr);\n    }\n};\n\nvoid example() {\n    // single element\n    auto ptr = new MyClass();\n    delete ptr;\n\n    // array\n    ptr = new MyClass[5];\n    delete[] ptr;\n}\n\nint main() {\n    example();\n}\n')),(0,r.kt)("h2",{id:"valgrind"},"Valgrind"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=/home/workspace/valgrind-out.txt /home/workspace/a.out\n\n")))}m.isMDXComponent=!0}}]);