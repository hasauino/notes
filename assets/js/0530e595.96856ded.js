"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[30],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),o=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=o(e.components);return a.createElement(i.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=d(e,["components","mdxType","originalType","parentName"]),m=o(t),p=r,h=m["".concat(i,".").concat(p)]||m[p]||c[p]||s;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,l=new Array(s);l[0]=m;var d={};for(var i in n)hasOwnProperty.call(n,i)&&(d[i]=n[i]);d.originalType=e,d.mdxType="string"==typeof e?e:r,l[1]=d;for(var o=2;o<s;o++)l[o]=t[o];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>d,toc:()=>o});var a=t(7462),r=(t(7294),t(3905));const s={},l="Concurrency",d={unversionedId:"C++/concurrency",id:"C++/concurrency",title:"Concurrency",description:"Running Threads",source:"@site/docs/C++/concurrency.md",sourceDirName:"C++",slug:"/C++/concurrency",permalink:"/notes/C++/concurrency",draft:!1,editUrl:"https://github.com/hasauino/notes/edit/master/docs/C++/concurrency.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"My Personal Notes",permalink:"/notes/"},next:{title:"Debugging",permalink:"/notes/C++/debugging"}},i={},o=[{value:"Running Threads",id:"running-threads",level:2},{value:"Detach",id:"detach",level:3},{value:"Thread with normal functions",id:"thread-with-normal-functions",level:3},{value:"Thread with Functors",id:"thread-with-functors",level:3},{value:"Thread with Lambda",id:"thread-with-lambda",level:3},{value:"Threads &amp; Variadic templates",id:"threads--variadic-templates",level:3},{value:"Starting threads with member functions",id:"starting-threads-with-member-functions",level:3},{value:"Running Multiple Threads",id:"running-multiple-threads",level:3},{value:"Fork-Join Parallelism",id:"fork-join-parallelism",level:4},{value:"Passing Data Between Threads",id:"passing-data-between-threads",level:2},{value:"Promise-Future",id:"promise-future",level:3},{value:"Example using <code>wait_for</code>",id:"example-using-wait_for",level:4},{value:"Passing Exceptions",id:"passing-exceptions",level:4},{value:"Threads VS. Tasks (std::async)",id:"threads-vs-tasks-stdasync",level:3},{value:"Avoiding Data Races",id:"avoiding-data-races",level:3},{value:"<code>enable_shared_from_this</code>",id:"enable_shared_from_this",level:3},{value:"Mutexes and Locks",id:"mutexes-and-locks",level:2},{value:"Using Mutex to Protect Shared Data",id:"using-mutex-to-protect-shared-data",level:3},{value:"Types of Mutexes",id:"types-of-mutexes",level:4},{value:"Dead-Locks",id:"dead-locks",level:4},{value:"Avoiding Dead Locks",id:"avoiding-dead-locks",level:4},{value:"1. Lock guards",id:"1-lock-guards",level:5},{value:"2. Unique Lock",id:"2-unique-lock",level:4},{value:"3. lock",id:"3-lock",level:4},{value:"Conditional Variables",id:"conditional-variables",level:3}],u={toc:o};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"concurrency"},"Concurrency"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <thread>\n\nvoid callback() {\n    std::cout << "callback..." << std::endl;\n}\n\n\nvoid example() {\n    std::thread thread{callback};\n    thread.join();\n}\n')),(0,r.kt)("h2",{id:"running-threads"},"Running Threads"),(0,r.kt)("p",null,"Threads can execute any callable in parallel to the main thread. A callable can be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A function (or function pointer)"),(0,r.kt)("li",{parentName:"ul"},"A lambda expression (in-line anonymous function)."),(0,r.kt)("li",{parentName:"ul"},"An object that overloads the call operator")),(0,r.kt)("p",null,'Lambdas and callable objects are also known as "',(0,r.kt)("strong",{parentName:"p"},"Functors"),'".'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"get hardware threads:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void example(){\n    unsigned int n_threads = std::thread::hardware_concurrency();\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Get thread ID")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread::get_id();\n")),(0,r.kt)("h3",{id:"detach"},"Detach"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Sets ",(0,r.kt)("inlineCode",{parentName:"li"},"joinable")," to false and suppress error if thread is destructed before finishing execution."),(0,r.kt)("li",{parentName:"ul"},"Detached threads can never be joined again."),(0,r.kt)("li",{parentName:"ul"},"OS will terminate detached threads harshly without giving them enough time to do proper clean-up (not waiting for destructor). ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#incldue <thread>\n#include <iostream>\n\nusing namespace chono_literals;\n\nvoid example(){\n    std::thread thread([](){\n        std::this_thread::sleep_for(500ms);\n    });\n    \n    thread.detach();\n    \n    std::cout << "Done main thread" << std::endl;\n}\n\n')),(0,r.kt)("h3",{id:"thread-with-normal-functions"},"Thread with normal functions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// simple\nvoid callback(){}\nstd::thread thread{callback};\n\n// with args\nvoid callback(const std::string& msg){}\nstd::thread thread{callback, "hello"};\n')),(0,r.kt)("h3",{id:"thread-with-functors"},"Thread with Functors"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Foo {\n   private:\n   public:\n    Foo() {}\n\n    void operator()() { std::cout << "Foo called!" << std::endl; }\n};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It could be ambiguous for the C++ compiler to parse an expression, as in the following case:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"}," Foo f();\n")),(0,r.kt)("p",null,"This can be a deceleration of ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," function that returns ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo"),". Or can be a instantiation of ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," . To resolve such ambiguity, the following can be done:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Foo f{};  // use uniform initialization\nauto f = Foo(); // use copy initialization\n")),(0,r.kt)("h3",{id:"thread-with-lambda"},"Thread with Lambda"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'std::thread thread{[](){\n    std::cout << "hello!" << std::endl;\n}};\n')),(0,r.kt)("p",null,"Lambda can take different forms:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// simple lambda \nauto hello = [](){\n    std::cout << "hello" << std::endl;\n};\n\n// omitted (), possible only when not using "mutable" specifier\nauto hello2 = []{\n    std::cout << "hello" << std::endl;\n};\n\nhello();\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// with parameters\nauto add = [](int a, int b){\n    std::cout << a+b << std::endl;\n};\n\nadd(1, 2);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// with capture list - by value\n\nint a=10, b=20;\n\nauto add = [a, b](){\n    std::cout << a+b << std::endl;\n};\n\n// by value, mutable (can change a)\nauto add = [a, b]() mutable {\n    a++;\n    std::cout << a+b << std::endl;\n};\n\n\nadd();\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// with capture list - by reference\n\nint a=10, b=20;\n\nauto add = [&a, &b](){\n    std::cout << a+b << std::endl;\n}\n\nadd(); // object created from a lambda is called a "closure" \n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// with return value (explicitly defined)\nauto sum = [](int a, int b) -> int{\n    return a+b;\n};\n\n// with return value (auto-deduction of return type)\nauto sum = [](int a, int b){\n    return a+b;\n};\n")),(0,r.kt)("p",null,"The object created from a lambda expression is called ",(0,r.kt)("strong",{parentName:"p"},"closure"),"."),(0,r.kt)("h3",{id:"threads--variadic-templates"},"Threads & Variadic templates"),(0,r.kt)("p",null,"The thread constructor is a variadic template function. So we can pass as many arguments as the callback function needs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void callback(const std::string& msg){}\n\nstd::thread thread{callback, "hello!"};\n')),(0,r.kt)("p",null,"When passing arguments to variadic functions, the behavior is slightly different than that of a normal function. Arguments are passed by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Copying (if passed argument is an lvalue)."),(0,r.kt)("li",{parentName:"ul"},"Moving (if passed argument is an rvalue)."),(0,r.kt)("li",{parentName:"ul"},"To move an ",(0,r.kt)("inlineCode",{parentName:"li"},"lvalue"),", you can use ",(0,r.kt)("inlineCode",{parentName:"li"},"std::move")),(0,r.kt)("li",{parentName:"ul"},"To force pass by reference, we have to use ",(0,r.kt)("inlineCode",{parentName:"li"},"std::ref()"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'std::string msg{"hello there!"};\n\nstd::thread thread{callback, std::ref(msg)};\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::ref")," can also be used with ",(0,r.kt)("inlineCode",{parentName:"li"},"std::bind")," to pass args by reference.")),(0,r.kt)("h3",{id:"starting-threads-with-member-functions"},"Starting threads with member functions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <memory>\n#include <thread>\n#include <vector>\n\nclass Dog {\n   public:\n    Dog(const std::string& name) : _name{name} {}\n    void make_sound() {\n        std::cout << "Dog " << this->_name << " Says: Wo Wo WO" << std::endl;\n    }\n\n   private:\n    std::string _name;\n};\n\nint main() {\n    Dog dog{"Cesar"};\n    std::thread thread{&Dog::make_sound, dog}; // a copy is made for dog\n    std::thread thread{&Dog::make_sound, &dog}; // by reference\n    thread.join();\n    return 0;\n}\n')),(0,r.kt)("p",null,"Better approach is to used heap-allocated object while making sure it's life is longer than the thread. Good choice is a shared pointer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'auto dog = std::make_shared<Dog>("Cesar");\nstd::thread thread{&Dog::make_sound, dog};\n')),(0,r.kt)("h3",{id:"running-multiple-threads"},"Running Multiple Threads"),(0,r.kt)("h4",{id:"fork-join-parallelism"},"Fork-Join Parallelism"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"split work across threads (worker threads) + main thread."),(0,r.kt)("li",{parentName:"ul"},"let main thread join all threads (join is the barrier).")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <vector>\n#include <thread>\n#include <iostream>\n\nint main(){\n    std::vector<std::thread> workers;\n    // fork\n    for (int i=0; i<5; i++){\n        workers.emplace_back(std::thread{[i](){\n            std::cout << "thread: " << i << std::endl;            \n        }});\n    }\n    //join\n    for (auto& worker : workers){\n        worker.join();\n    }\n    \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"passing-data-between-threads"},"Passing Data Between Threads"),(0,r.kt)("h3",{id:"promise-future"},"Promise-Future"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nvoid callback(std::promise<std::string>&& promise) {\n    std::this_thread::sleep_for(2s);\n    promise.set_value("done");\n}\n\nint main() {\n    std::promise<std::string> promise;\n    auto future = promise.get_future();\n    std::thread t{callback, std::move(promise)};\n\n    std::cout << "Waiting.." << std::endl;\n\n    auto msg = future.get();\n    std::cout << "Got this message:\\n" << msg << std::endl;\n\n    t.join();\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"example-using-wait_for"},"Example using ",(0,r.kt)("inlineCode",{parentName:"h4"},"wait_for")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nvoid callback(std::promise<std::string>&& promise) {\n    std::cout << "please press Enter\\n";\n    std::cin.get();\n    promise.set_value("done");\n}\n\nint main() {\n    std::promise<std::string> promise;\n    auto future = promise.get_future();\n    std::thread t{callback, std::move(promise)};\n\n    std::cout << "Waiting.." << std::endl;\n\n    auto status = future.wait_for(2s);\n    if (status != std::future_status::ready) {\n        std::cout << "Error!" << std::endl;\n        return -1;\n    }\n    auto msg = future.get();\n    std::cout << "Got this message:\\n" << msg << std::endl;\n\n    t.join();\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"passing-exceptions"},"Passing Exceptions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <future>\n#include <iostream>\n#include <memory>\n#include <stdexcept>\n#include <thread>\n\nvoid callback(std::promise<std::string>&& promise) {\n    throw std::runtime_error("Error!");\n}\n\nint main() {\n    std::promise<std::string> promise;\n    auto future = promise.get_future();\n    std::thread t{callback, std::move(promise)};\n\n    auto msg = future.get();\n\n    t.join();\n\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"threads-vs-tasks-stdasync"},"Threads VS. Tasks (std::async)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <functional>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <stdexcept>\n#include <thread>\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        throw std::runtime_error("Cannot divide by Zero!");\n    }\n    return a / b;\n}\n\nint main() {\n    auto future = std::async(divide, 10, 20);\n    try {\n        std::cout << future.get() << std::endl;\n    } catch (std::exception e) {\n        std::cout << e.what() << std::endl;\n    }\n\n    return 0;\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The system decides whether to run the function in a separate thread or the caller's thread.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We can enforce that using the launch parameter:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::async(std::launch::deferred, divide, 10, 20); // sync - same thread\nstd::async(std::launch::async, divide, 10, 20);    // async - separate thread \n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Starting threads is expensive. For low computation loads, using a single thread can be faster. The overhead of running threads must be less than the gain in speed of using multi-cores for it to be useful."))),(0,r.kt)("h3",{id:"avoiding-data-races"},"Avoiding Data Races"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Passing by value is a safe way to avoid data races.")),(0,r.kt)("h3",{id:"enable_shared_from_this"},(0,r.kt)("inlineCode",{parentName:"h3"},"enable_shared_from_this")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Example : public std::enable_shared_from_this<Vehicle>\n{\npublic:\n    // constructor / desctructor\n    std::shared_ptr<Example> foo(){\n        return get_shared_this;\n    }\n};\n")),(0,r.kt)("h2",{id:"mutexes-and-locks"},"Mutexes and Locks"),(0,r.kt)("p",null,"Mutex = Mutual Exclusion."),(0,r.kt)("h3",{id:"using-mutex-to-protect-shared-data"},"Using Mutex to Protect Shared Data"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <cstddef>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nusing namespace std::chrono_literals;\n\nvoid greeting(std::shared_ptr<std::mutex> mutex) {\n    mutex->lock();\n    std::cout << "hello World!" << std::endl;\n    std::this_thread::sleep_for(1us);\n    mutex->unlock();\n}\n\nint main() {\n    std::size_t number_threads{10};\n    auto mutex = std::make_shared<std::mutex>();\n    std::vector<std::thread> threads{number_threads};\n\n    for (int i = 0; i < number_threads; i++) {\n        threads[i] = std::thread{&greeting, mutex};\n    }\n\n    for (int i = 0; i < number_threads; i++) {\n        threads[i].join();\n    }\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"types-of-mutexes"},"Types of Mutexes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mutex"),": normal ",(0,r.kt)("inlineCode",{parentName:"li"},"lock()"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"unlock()"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"try_lock()"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"recursive_mutex"),": same thread can acquire the lock multiple times."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"timed_mutex"),": adds ",(0,r.kt)("inlineCode",{parentName:"li"},"try_lock_for()"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"try_lock_until()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"recursive_timed_mutex"),": combo of ",(0,r.kt)("inlineCode",{parentName:"li"},"recursive_mutex")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"timed_mutex"),".")),(0,r.kt)("h4",{id:"dead-locks"},"Dead-Locks"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1"),": Error raised preventing ",(0,r.kt)("inlineCode",{parentName:"p"},"unlock()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <exception>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nint main() {\n    auto mutex = std::make_shared<std::mutex>();\n    auto f1 = std::async([mutex]() {\n        std::cout << "thread 1 waiting lock...\\n";\n        mutex->lock();\n        std::cout << "thread 1 error...\\n";\n        throw std::runtime_error("Error");\n        mutex->unlock();\n    });\n\n    auto f2 = std::async([mutex]() {\n        std::this_thread::sleep_for(1us);\n        std::cout << "thread 2 waiting lock...\\n";\n        mutex->lock();\n        std::cout << "thread 2 running...\\n";\n        mutex->unlock();\n    });\n\n    f1.wait();\n    f2.wait();\n\n    return 0;\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2"),": cyclic dependency on locks"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <algorithm>\n#include <chrono>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <thread>\n#include <vector>\n\nusing namespace std::chrono_literals;\n\nint main() {\n    auto m1 = std::make_shared<std::mutex>();\n    auto m2 = std::make_shared<std::mutex>();\n\n    std::thread t1{[m1, m2]() {\n        std::cout << "t1 acquiring m1 lock\\n";\n        m1->lock();\n        std::this_thread::sleep_for(1us);\n        std::cout << "t1 m1 locked\\n";\n        std::cout << "t1 acquiring m2 lock\\n";\n        m2->lock();\n        std::cout << "t1 m2 locked\\n";\n        m2->unlock();\n        std::cout << "t1 m2 un-locked\\n";\n        m1->unlock();\n        std::cout << "t1 m1 un-locked\\n";\n    }};\n    std::thread t2{[m1, m2]() {\n        std::cout << "t2 acquiring m2 lock\\n";\n        m2->lock();\n        std::this_thread::sleep_for(1us);\n        std::cout << "t2 m2 locked\\n";\n        std::cout << "t2 acquiring m1 lock\\n";\n        m1->lock();\n        std::cout << "t2 m1 locked\\n";\n        m1->unlock();\n        std::cout << "t2 m1 un-locked\\n";\n        m2->unlock();\n        std::cout << "t2 m2 un-locked\\n";\n    }};\n\n    t1.join();\n    t2.join();\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"avoiding-dead-locks"},"Avoiding Dead Locks"),(0,r.kt)("h5",{id:"1-lock-guards"},"1. Lock guards"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nint main() {\n    auto stream_mutex = std::make_shared<std::mutex>();\n\n    auto f1 = std::async([stream_mutex]() {\n        std::lock_guard<std::mutex> lock{*stream_mutex};\n        std::this_thread::sleep_for(100ms);\n        std::cout << "thread 1\\n";\n    });\n\n    auto f2 = std::async([stream_mutex]() {\n        std::lock_guard<std::mutex> lock{*stream_mutex};\n        std::this_thread::sleep_for(100ms);\n        std::cout << "thread 2\\n";\n    });\n\n    f1.wait();\n    f2.wait();\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"2-unique-lock"},"2. Unique Lock"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <future>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <thread>\n\nusing namespace std::chrono_literals;\n\nint main() {\n    auto stream_mutex = std::make_shared<std::mutex>();\n\n    auto f1 = std::async([stream_mutex]() {\n        std::unique_lock<std::mutex> lock{*stream_mutex};\n        std::this_thread::sleep_for(100ms);\n        std::cout << "thread 1\\n";\n        lock.unlock();\n        std::this_thread::sleep_for(100ms);\n        lock.lock();\n        std::cout << "thread 1 again!\\n";\n    });\n\n    auto f2 = std::async([stream_mutex]() {\n        std::unique_lock<std::mutex> lock{*stream_mutex};\n        std::this_thread::sleep_for(100ms);\n        std::cout << "thread 2\\n";\n        lock.unlock();\n        std::this_thread::sleep_for(100ms);\n        lock.lock();\n        std::cout << "thread 2 again!\\n";\n    });\n\n    f1.wait();\n    f2.wait();\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"3-lock"},"3. lock"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::lock")," makes sure both mutexes are locked at the same time."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <thread>\n#incldue <iostream>\n#include <chrono>\n#include <mutex>\n\nusing namespace std::chrono_literals;\n\nint main(){\n    std::mutex m1, m2;\n    std::thread t1{[&m1, &m2](){\n        std::lock(m1, m2);\n        std::unique_lock lock1{m1}, lock2{m2};\n        lock1.lock();\n        std::cout << "t1 - 1\\n";\n        lock2.lock();\n        std::cout << "t1 - 2\\n";\n        lock2.unlock();\n        lock1.unlock();\n    }};\n\n    std::thread t2{[&m1, &m2](){\n        std::lock(m1, m2);\n        std::unique_lock lock1{m1}, lock2{m2};\n        lock2.lock();\n        std::cout << "t1 - 1\\n";\n        lock1.lock();\n        std::cout << "t1 - 2\\n";\n        lock1.unlock();\n        lock2.unlock();\n    }};    \n    return 0;\n}\n')),(0,r.kt)("h3",{id:"conditional-variables"},"Conditional Variables"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <condition_variable>\n#include <cstddef>\n#include <deque>\n#include <iostream>\n#include <memory>\n#include <mutex>\n#include <sstream>\n#include <string>\n#include <thread>\n#include <vector>\n\nusing namespace std::chrono_literals;\nstd::mutex cout_mutex;\n\ntemplate <typename T>\nclass MessageQueue {\n   public:\n    T read() {\n        while (1) {\n            std::unique_lock<std::mutex> guard{this->_mutex};\n            if (this->_queue.empty()) {\n                this->_conditional_variable.wait(guard);\n                continue;\n            }\n            auto msg = this->_queue[0];\n            this->_queue.pop_front();\n            return msg;\n        }\n    }\n    void write(T msg) {\n        std::unique_lock<std::mutex> guard{this->_mutex};\n        this->_queue.push_back(msg);\n        guard.unlock();\n        this->_conditional_variable.notify_all();\n    }\n\n   private:\n    std::deque<T> _queue;\n    std::mutex _mutex;\n    std::condition_variable _conditional_variable;\n};\n\nint main() {\n    std::size_t n_writers{5};\n    std::size_t n_readers{10};\n    auto queue = std::make_shared<MessageQueue<std::string>>();\n\n    std::vector<std::thread> writer_threads;\n    for (int thread_id = 0; thread_id < n_writers; thread_id++) {\n        writer_threads.emplace_back(std::thread{[queue, thread_id]() {\n            for (int i = 0;; i++) {\n                std::stringstream ss;\n                ss << "Hello " << i << ", from Writer " << thread_id;\n                queue->write(ss.str());\n                std::this_thread::sleep_for(\n                    std::chrono::seconds{thread_id * 2 + 1});\n            }\n        }});\n    }\n\n    std::vector<std::thread> reader_threads;\n    for (int thread_id = 0; thread_id < n_readers; thread_id++) {\n        reader_threads.emplace_back(std::thread{[queue, thread_id]() {\n            while (1) {\n                auto msg = queue->read();\n\n                std::unique_lock<std::mutex> cout_guard{cout_mutex};\n                std::cout << "Reader " << thread_id << ", got msg: " << msg\n                          << std::endl;\n                cout_guard.unlock();\n\n                std::this_thread::sleep_for(100ms);\n            }\n        }});\n    }\n\n    for (auto& thread : writer_threads) {\n        thread.join();\n    }\n    for (auto& thread : reader_threads) {\n        thread.join();\n    }\n\n    return 0;\n}\n')))}c.isMDXComponent=!0}}]);