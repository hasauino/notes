"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[127],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(h,s(s({ref:n},p),{},{components:t})):a.createElement(h,s({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=u;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1910:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},s="Memory",i={unversionedId:"C++/memory",id:"C++/memory",title:"Memory",description:"Memory Types",source:"@site/docs/C++/memory.md",sourceDirName:"C++",slug:"/C++/memory",permalink:"/notes/C++/memory",draft:!1,editUrl:"https://github.com/hasauino/notes/edit/master/docs/C++/memory.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Debugging",permalink:"/notes/C++/debugging"},next:{title:"C++ Tips + Style",permalink:"/notes/C++/modern_cpp"}},l={},c=[{value:"Memory Types",id:"memory-types",level:2},{value:"Virtual Memory",id:"virtual-memory",level:2},{value:"Cache",id:"cache",level:2},{value:"Process Memory Model",id:"process-memory-model",level:2},{value:"<code>malloc</code>, <code>calloc</code>, <code>realloc</code>, and <code>free</code>",id:"malloc-calloc-realloc-and-free",level:2},{value:"<code>new</code> and <code>delete</code>",id:"new-and-delete",level:2},{value:"Overriding <code>new</code>/<code>delete</code> operators",id:"overriding-newdelete-operators",level:3},{value:"Valgrind",id:"valgrind",level:2},{value:"Copy &amp; Move Semantics",id:"copy--move-semantics",level:2},{value:"Copy-ownership Policy",id:"copy-ownership-policy",level:3},{value:"1. No copying/moving",id:"1-no-copyingmoving",level:4},{value:"2. Exclusive Ownership",id:"2-exclusive-ownership",level:4},{value:"3. Deep Copy",id:"3-deep-copy",level:4},{value:"4. Shared Ownership",id:"4-shared-ownership",level:4},{value:"Rule of Three",id:"rule-of-three",level:4},{value:"rvalue &amp; lvalue",id:"rvalue--lvalue",level:3},{value:"rvalue reference",id:"rvalue-reference",level:4},{value:"Essential Operations",id:"essential-operations",level:2},{value:"Copying",id:"copying",level:3},{value:"Moving",id:"moving",level:3},{value:"Rule of 5",id:"rule-of-5",level:3},{value:"Operator Chaining",id:"operator-chaining",level:3},{value:"Moving an lvalue",id:"moving-an-lvalue",level:3},{value:"Smart Pointers",id:"smart-pointers",level:2},{value:"RAII",id:"raii",level:3},{value:"Unique Pointer",id:"unique-pointer",level:3},{value:"Shared Pointer",id:"shared-pointer",level:3},{value:"Weak Pointer",id:"weak-pointer",level:3},{value:"Performance",id:"performance",level:3},{value:"Conversion between smart pointers",id:"conversion-between-smart-pointers",level:3},{value:"Transferring Ownership",id:"transferring-ownership",level:3},{value:"Tips",id:"tips",level:2},{value:"enable_shared_from_this",id:"enable_shared_from_this",level:3}],p={toc:c};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"memory"},"Memory"),(0,r.kt)("h2",{id:"memory-types"},"Memory Types"),(0,r.kt)("p",null,"In computers, there are multiple types of memory. The following is a list of memory types ordered from closest/fastest to furthest/slowest:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"CPU registers."),(0,r.kt)("li",{parentName:"ol"},"L1 cache."),(0,r.kt)("li",{parentName:"ol"},"L2 cache."),(0,r.kt)("li",{parentName:"ol"},"L3 cache (facilitates the protocol used for caching in multi-core CPUs)."),(0,r.kt)("li",{parentName:"ol"},"RAM/ROM (not sure which one is faster)."),(0,r.kt)("li",{parentName:"ol"},"Hard disks (HDD, SDD)...etc")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CPU registers, the cache memory (L1-L3), are not directly accessible by the programmer."),(0,r.kt)("li",{parentName:"ul"},"A very important memory type, though not physical, is ",(0,r.kt)("strong",{parentName:"li"},"Virtual Memory"),".")),(0,r.kt)("h2",{id:"virtual-memory"},"Virtual Memory"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each program is mapped to a virtual memory space which is mapped to the physical memory (RAM, and also hard disk - swap)."),(0,r.kt)("li",{parentName:"ul"},"Physical memory is mainly the RAM (but it also include other device registers)."),(0,r.kt)("li",{parentName:"ul"},"So a program does not interact with the physical memory directly and does not use the physical addresses.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Why?")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To avoid having programs competing against same address space."),(0,r.kt)("li",{parentName:"ul"},"Solves the problem of fragmentation: allocating large chunks of memory when there is fragmentation could fail even when there is still free physical space."),(0,r.kt)("li",{parentName:"ul"},"each program now is not limited by the available free space in the RAM. Since virtual memory could be mapped to hard disk in case no available free space or in case of ",(0,r.kt)("strong",{parentName:"li"},"page fault")," (when there is less RAM available the largest addressable location in the memory).")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When the RAM is full, the operating system starts swapping: it moves a chunk of memory from the RAM to the hard disk. The swapped memory could be stored in a file (swap file), or a partition (swap partition). In Linux, you could check how much swap is used using these commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"free -h\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"swapon --show\n")),(0,r.kt)("h2",{id:"cache"},"Cache"),(0,r.kt)("p",null,"In CPUs, there is a caching mechanism which stores chunks of memory that is likely to be used for speeding up access to it. Cache memory is something the programmer does not have access to, but there are 2 things that should be kept in mind:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Temporal Locality"),": data that was accessed recently, will be more likely cached than data access earlier."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Spacial Locality"),": data closer to recently accessed data is more likely to be cached.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <chrono>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nvoid contigious(unsigned long rows, unsigned long cols) {\n    int* matrix = new int[rows * cols];\n\n    auto t_start = chrono::high_resolution_clock::now();\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            *(matrix + (i * cols + j)) = 1;\n        }\n    }\n    auto t_end = chrono::high_resolution_clock::now();\n    auto duration = t_end - t_start;\n    printf("contigious access duration: %ld\\n", duration.count());\n}\n\nvoid non_contigious(unsigned long rows, unsigned long cols) {\n    int* matrix = new int[rows * cols];\n\n    auto t_start = chrono::high_resolution_clock::now();\n    for (int j = 0; j < cols; j++) {\n        for (int i = 0; i < rows; i++) {\n            *(matrix + (i * cols + j)) = 1;\n        }\n    }\n    auto t_end = chrono::high_resolution_clock::now();\n    auto duration = t_end - t_start;\n    printf("non-contigious access duration: %ld\\n", duration.count());\n}\n\nint main(int argc, char** argv) {\n    contigious(10000, 10000);\n    non_contigious(10000, 10000);\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"process-memory-model"},"Process Memory Model"),(0,r.kt)("p",null,"Each process is given a virtual memory space by the operating system. It consists of the following sections:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"OS kernel."),(0,r.kt)("li",{parentName:"ol"},"Stack: Automatic variables in local scopes."),(0,r.kt)("li",{parentName:"ol"},"Heap: Dynamically allocated variables."),(0,r.kt)("li",{parentName:"ol"},"BSS: uninitialized static variables."),(0,r.kt)("li",{parentName:"ol"},"Data: explicitly initialized static variables"),(0,r.kt)("li",{parentName:"ol"},"Text: program code")),(0,r.kt)("p",null,"variables in sections 4 & 5 are allocated once at start and persist throughout the program lifetime. "),(0,r.kt)("h2",{id:"malloc-calloc-realloc-and-free"},(0,r.kt)("inlineCode",{parentName:"h2"},"malloc"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"calloc"),", ",(0,r.kt)("inlineCode",{parentName:"h2"},"realloc"),", and ",(0,r.kt)("inlineCode",{parentName:"h2"},"free")),(0,r.kt)("p",null,"These are functions which are part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"stdlib.h")," header file in C."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdlib>\n#include <cstddef>\n#include <string>\n\nusing namespace std;\n\n// malloc & free\nvoid example_1(){\n    int* ptr = (int*)malloc(sizeof(int));\n    *ptr = 10;\n    free(ptr);\n}\n\n// calloc\nvoid example_2(){\n    size_t size{10};\n    int* ptr = (int*)calloc(size, sizeof(int));\n    for (int i=0; i<size; i++){\n        ptr[i] = 0;\n    }\n    free(ptr);\n}\n\n// array of custom type\nvoid example_3(){\n    struct Person{\n        string first_name;\n        string last_name;\n        float age;\n    };\n    \n    Person* students = (Person*) calloc(3, sizeof(Person));\n    students[0].first_name = "Hassan";\n    students[0].last_name = "Umari";\n    students[0].age = 33.0;\n}\n\n// realloc\nvoid example_4(){\n    int* ptr = (int*)malloc(sizeof(int));\n    int* ptr = (int*)realloc(ptr, 2*sizeof(int));\n    ptr[0] = 10;\n    ptr[1] = 100;\n    free(ptr);    \n}\n')),(0,r.kt)("h2",{id:"new-and-delete"},(0,r.kt)("inlineCode",{parentName:"h2"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"delete")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," operators are the C++ counter part of C  ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"free")," functions. The following are the differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"new")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"delete")," are operators. They can be overloaded in classes unlike ",(0,r.kt)("inlineCode",{parentName:"li"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"free")," which are functions."),(0,r.kt)("li",{parentName:"ul"},"Instantiating an object with  ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," automatically calls the constructor. Similarly, with ",(0,r.kt)("inlineCode",{parentName:"li"},"delete")," , the destructor is automatically called."),(0,r.kt)("li",{parentName:"ul"},"type safety: ",(0,r.kt)("inlineCode",{parentName:"li"},"malloc")," returns a void pointer which needs to be cast into the appropriate type.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdio>\n#include <string>\n\nusing namespace std;\n\n// simple example\nvoid example_1() {\n    int* ptr = new int(10);\n    ptr[0] = 100;\n    delete ptr;\n}\n\n// array of simple types\nvoid example_2() {\n    int* ptr = new int[3];\n    ptr[0] = 1;\n    ptr[1] = 2;\n    ptr[2] = 3;\n    delete[] ptr;\n}\n\n// array of custom types\nvoid example_3() {\n\n    struct Person {\n        string name;\n        float age;\n    };\n\n    int count{10};\n    Person* people = new Person[count];\n\n    for (int i = 0; i < count; i++) {\n        people[i].name = "Hassan Umari";\n        people[i].age = 33.0;\n    }\n    delete[] people;\n}\n\n// placement new operator example\nvoid example_4() {\n\n    struct Person {\n        string name;\n        float age;\n\n        ~Person() { printf("Person destructor\\n"); }\n    };\n\n    Person* hassan = (Person*)malloc(sizeof(Person));\n    new (hassan) Person;\n    hassan->~Person();\n    free(hassan); // must use free in this case (cannot use delete). Hence the explicit call to the destructor \n}\n')),(0,r.kt)("h3",{id:"overriding-newdelete-operators"},"Overriding ",(0,r.kt)("inlineCode",{parentName:"h3"},"new"),"/",(0,r.kt)("inlineCode",{parentName:"h3"},"delete")," operators"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nclass MyClass {\n   public:\n    MyClass() { printf("Constructor..\\n"); }\n    ~MyClass() { printf("Destructor..\\n"); }\n\n    void* operator new(size_t size) {\n        printf("allocating memory..\\n");\n        return malloc(size);\n    }\n\n    void* operator new[](size_t size) {\n        printf("allocating memory..\\n");\n        return malloc(size);\n    }\n\n    void operator delete(void* ptr) {\n        printf("freeing memory..\\n");\n        free(ptr);\n    }\n\n    void operator delete[](void* ptr) {\n        printf("freeing memory..\\n");\n        free(ptr);\n    }\n};\n\nvoid example() {\n    // single element\n    auto ptr = new MyClass();\n    delete ptr;\n\n    // array\n    ptr = new MyClass[5];\n    delete[] ptr;\n}\n\nint main() {\n    example();\n}\n')),(0,r.kt)("h2",{id:"valgrind"},"Valgrind"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --log-file=/home/workspace/valgrind-out.txt /home/workspace/a.out\n\n")),(0,r.kt)("h2",{id:"copy--move-semantics"},"Copy & Move Semantics"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Without defining a copy or move constructor/operator, the compiler defines default ones which perform a shallow copy/move.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstddef>\n#include <iostream>\n\nusing namespace std;\n\nclass Simple{\n    public:\n        Simple(size_t size){\n            this->memory_block = new int[size];\n        }\n        ~Simple(){\n            delete[] this->memory_block;\n        }\n        void print_addresses(){\n            cout << "Object address: " << this << endl;\n            cout << "Memory block address: " << this->memory_block << endl;\n        }\n    private:\n        int* memory_block;\n};\n\n\nvoid example(){\n    Simple object1{10};\n    Simple object2{object1};\n    \n    object1.print_addresses();\n    object2.print_addresses();\n    \n    // when destructors are called, an error will be raised due to releasing same memory twice \n}\n')),(0,r.kt)("h3",{id:"copy-ownership-policy"},"Copy-ownership Policy"),(0,r.kt)("p",null,"A design choice must be made when creating a class, is the copying policy."),(0,r.kt)("h4",{id:"1-no-copyingmoving"},"1. No copying/moving"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"\nclass NoCopyNoMove{\n    public:\n        NoCopyNoMove(const NoCopyNoMove& other) = delete;\n        NoCopyNoMove& operator=(const NoCopyNoMove& other) = delete;\n    \n        NoCopyNoMove(NoCopyNoMove&& other) = delete();\n        NoCopyNoMove& operator=(NoCopyNoMove&& other) = delete;\n};\n")),(0,r.kt)("h4",{id:"2-exclusive-ownership"},"2. Exclusive Ownership"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <cstddef>\n#include <utility>\n\nusing namespace std;\n\nclass Example{\n    public:\n        Example(size_t size){\n            memory_block = new int[size];            \n        };\n        ~Example(){\n            delete[] memory_block;\n        }\n        Example(Example& other) = delete;\n        Example& operator=(Example& other) = delete;\n    \n        Example(Example&& other){\n            this->memory_block = other.memory_block;\n            other.memory_block = nullptr;\n        }\n    private:\n        int* memory_block;\n};\n\nint main(int argc, char** argv) {\n    Example object1{10};\n    Example object2{move(object1)};\n    return 0;\n}\n")),(0,r.kt)("h4",{id:"3-deep-copy"},"3. Deep Copy"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nclass DeepCopy\n{\nprivate:\n    int *_myInt;\n\npublic:\n    DeepCopy(int val)\n    {\n        _myInt = (int *)malloc(sizeof(int));\n        *_myInt = val;\n        std::cout << "resource allocated at address " << _myInt << std::endl;\n    }\n    ~DeepCopy()\n    {\n        free(_myInt);\n        std::cout << "resource freed at address " << _myInt << std::endl;\n    }\n    DeepCopy(DeepCopy &source)\n    {\n        _myInt = (int *)malloc(sizeof(int));\n        *_myInt = *source._myInt;\n        std::cout << "resource allocated at address " << _myInt << " with _myInt = " << *_myInt << std::endl;\n    }\n    DeepCopy &operator=(DeepCopy &source)\n    {\n        _myInt = (int *)malloc(sizeof(int));\n        std::cout << "resource allocated at address " << _myInt << " with _myInt=" << *_myInt << std::endl;\n        *_myInt = *source._myInt;\n        return *this;\n    }\n};\n\nint main()\n{\n    DeepCopy source(42);\n    DeepCopy dest1(source);\n    DeepCopy dest2 = dest1;\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"4-shared-ownership"},"4. Shared Ownership"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nclass SharedCopy\n{\nprivate:\n    int *_myInt;\n    static int _cnt;\n\npublic:\n    SharedCopy(int val);\n    ~SharedCopy();\n    SharedCopy(SharedCopy &source);\n};\n\nint SharedCopy::_cnt = 0;\n\nSharedCopy::SharedCopy(int val)\n{\n    _myInt = (int *)malloc(sizeof(int));\n    *_myInt = val;\n    ++_cnt;\n    std::cout << "resource allocated at address " << _myInt << std::endl;\n}\n\nSharedCopy::~SharedCopy()\n{\n    --_cnt;\n    if (_cnt == 0)\n    {\n        free(_myInt);\n        std::cout << "resource freed at address " << _myInt << std::endl;\n    }\n    else\n    {\n        std::cout << "instance at address " << this << " goes out of scope with _cnt = " << _cnt << std::endl;\n    }\n}\n\nSharedCopy::SharedCopy(SharedCopy &source)\n{\n    _myInt = source._myInt;\n    ++_cnt;\n    std::cout << _cnt << " instances with handles to address " << _myInt << " with _myInt = " << *_myInt << std::endl;\n}\n\nint main()\n{\n    SharedCopy source(42);\n    SharedCopy destination1(source);\n    SharedCopy destination2(source);\n    SharedCopy destination3(source);\n\n    return 0;\n}\n')),(0,r.kt)("h4",{id:"rule-of-three"},"Rule of Three"),(0,r.kt)("p",null,"If a class defines on of: a destructor, copy constructor, or copy assignment operator, then it must define the other two and properly manage resources."),(0,r.kt)("h3",{id:"rvalue--lvalue"},"rvalue & lvalue"),(0,r.kt)("p",null,"Here's an example that demonstrates the difference between an lvalue and an rvalue:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int x = 5;   // "x" is an lvalue\nint y = x;   // "x" is an lvalue, "y" is also an lvalue\nint z = 3 + 4;   // "3 + 4" is an rvalue, "z" is an lvalue\n')),(0,r.kt)("h4",{id:"rvalue-reference"},"rvalue reference"),(0,r.kt)("p",null,"An rvalue reference is a new feature introduced in C++11, which extends the concept of reference types in C++. An rvalue reference is a reference that is used to refer to an object that has a limited lifespan, often referred to as an rvalue."),(0,r.kt)("p",null,"In C++, an lvalue is an expression that refers to an object that has a persistent storage location in memory, such as a variable, an array, or a struct. An rvalue, on the other hand, is an expression that refers to a temporary value that is not stored in a persistent location in memory, such as the result of a function call or a literal value."),(0,r.kt)("p",null,'An rvalue reference can be declared using the "&&" symbol. Here\'s an example that demonstrates how an rvalue reference can be used:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int&& r = 5 + 6; % rvalue reference\nint a{5};\nint& b = a; % lvalue refernece\nstd::cout << r << std::endl;\n")),(0,r.kt)("p",null,'In this example, the expression "5 + 6" is an rvalue, and the rvalue reference "r" is used to refer to it. The rvalue reference "r" can be used in the same way as an lvalue reference to access the value of the temporary object.'),(0,r.kt)("p",null,"Rvalue references are often used in move semantics, which is a technique that enables efficient transfer of resources from one object to another. Move semantics can be used to avoid unnecessary copying of objects, which can improve the performance of C++ programs. Rvalue references are also used to implement perfect forwarding, which is a technique for forwarding function arguments to other functions without losing their value category (lvalue or rvalue)."),(0,r.kt)("h2",{id:"essential-operations"},"Essential Operations"),(0,r.kt)("h3",{id:"copying"},"Copying"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <algorithm>\n#include <initializer_list>\n#include "spdlog/spdlog.h"\n\nclass Vector {\n public:\n  Vector(int _size) : size{_size}, elem{new double[_size]} {};\n  ~Vector() {\n    spdlog::info("destructor..");\n    delete[] elem;\n  }\n  Vector(std::initializer_list<double> elem_)\n      : size{static_cast<int>(elem_.size())}, elem{new double[elem_.size()]} {\n    std::copy(elem_.begin(), elem_.end(), elem);\n  }\n\n  Vector(const Vector& v) : size{v.size}, elem{new double[v.size]} {\n    spdlog::info("copy constructor..");\n    std::copy(v.elem, v.elem + size, elem);\n  }\n\n  const double& operator[](int indx) const { return elem[indx]; }\n  double& operator[](int indx) { return elem[indx]; }\n\n  Vector& operator=(const Vector& v) {\n    double* temp = new double[v.size];\n    std::copy(v.elem, v.elem + v.size, temp);\n    delete[] elem;\n    elem = temp;\n    size = v.size;\n    return *this;\n  }\n\n private:\n  double* elem;\n  int size = 0;\n};\n\nint main(int argc, char** argv) {\n  Vector v({1.0, 2.0, 3.0});\n  Vector vv(v);\n  Vector vvv({100, 22, 33, 44, 55});\n  vvv = v;\n  auto vvvv =\n      v;  // this will call copy constructor (if u add "explicit" it will raise an error)\n  v[0] = 12345;\n  spdlog::info("{}        {}          {}", v[0], vv[0], vvv[0]);\n  return 0;\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"copy assignment operator is not called when we instantiate an object. Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"MyClass obj2 = obj1; // will call the copy constructor\nobj2 = obj1; // will call copy assignment operator \n")),(0,r.kt)("h3",{id:"moving"},"Moving"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A move operation is performed when an rvalue reference is used as:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"an initializer"),(0,r.kt)("li",{parentName:"ul"},"right hand side of an assignment")),(0,r.kt)("p",{parentName:"li"},"For the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector")," class, move constructor and move assignment might look like this:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"  Vector(Vector&& v) : size{static_cast<int>(v.size)}, elem{v.elem} {\n    v.elem = nullptr;\n    v.size = 0;\n  }\n\n  Vector& operator=(Vector&& v) {\n    delete[] elem;\n    elem = v.elem;\n    size = v.size;\n    v.size = 0;\n    v.elem = nullptr;\n  }\n")),(0,r.kt)("h3",{id:"rule-of-5"},"Rule of 5"),(0,r.kt)("p",null,"Exmaple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdlib.h>\n#include <iostream>\n\nclass MyMovableClass\n{\nprivate:\n    int _size;\n    int *_data;\n\npublic:\n    MyMovableClass(size_t size) // constructor\n    {\n        _size = size;\n        _data = new int[_size];\n        std::cout << "CREATING instance of MyMovableClass at " << this << " allocated with size = " << _size*sizeof(int)  << " bytes" << std::endl;\n    }\n\n    ~MyMovableClass() // 1 : destructor\n    {\n        std::cout << "DELETING instance of MyMovableClass at " << this << std::endl;\n        delete[] _data;\n    }\n    \n    MyMovableClass(const MyMovableClass &source) // 2 : copy constructor\n    {\n        _size = source._size;\n        _data = new int[_size];\n        *_data = *source._data;\n        std::cout << "COPYING content of instance " << &source << " to instance " << this << std::endl;\n    }\n    \n    MyMovableClass &operator=(const MyMovableClass &source) // 3 : copy assignment operator\n    {\n        std::cout << "ASSIGNING content of instance " << &source << " to instance " << this << std::endl;\n        if (this == &source)\n            return *this;\n        delete[] _data;\n        _data = new int[source._size];\n        *_data = *source._data;\n        _size = source._size;\n        return *this;\n    }\n    MyMovableClass(MyMovableClass &&source) // 4 : move constructor\n    {\n        std::cout << "MOVING (c\u2019tor) instance " << &source << " to instance " << this << std::endl;\n        _data = source._data;\n        _size = source._size;\n        source._data = nullptr;\n        source._size = 0;\n    }\n    MyMovableClass &operator=(MyMovableClass &&source) // 5 : move assignment operator\n    {\n        std::cout << "MOVING (assign) instance " << &source << " to instance " << this << std::endl;\n        if (this == &source)\n            return *this;\n\n        delete[] _data;\n\n        _data = source._data;\n        _size = source._size;\n\n        source._data = nullptr;\n        source._size = 0;\n\n        return *this;\n    }    \n};\n\nvoid useObject(MyMovableClass obj)\n{\n    std::cout << "using object " << &obj << std::endl;\n}\n\nint main()\n{\n    MyMovableClass obj1(100); // constructor\n\n    useObject(std::move(obj1));\n\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"operator-chaining"},"Operator Chaining"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Both the copy and move assignment operators return a reference to the object. This is needed to allow ",(0,r.kt)("strong",{parentName:"li"},"operator chaining"),"."),(0,r.kt)("li",{parentName:"ul"},"Always check of self-assignment when overloading assignment operators.")),(0,r.kt)("h3",{id:"moving-an-lvalue"},"Moving an lvalue"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"When an rvalue reference is passed to the constructor, the move constructor will be the one called, but when an lvalue reference is passed, the copy constructor will be called instead. To force the compiler to choose the move constructor, ",(0,r.kt)("inlineCode",{parentName:"li"},"std::move()")," can be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::move()")," is function that accepts an lvalue and returns it as an rvalue.")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nvoid useObject(MyMovableClass obj)\n{\n    std::cout << "using object " << &obj << std::endl;\n}\n\nint main()\n{\n    MyMovableClass obj1(100); // constructor\n\n    useObject(std::move(obj1));\n\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"smart-pointers"},"Smart Pointers"),(0,r.kt)("h3",{id:"raii"},"RAII"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"It's a programming paradaim in which allocated resources are managed by a manager class. Resources are tied to the life time of the manager class. The manager class shall aquire the resources on construction and release them upon destruction. Resources include: memeory, files, netowrk sockets, communication ports, threading locks, etc..")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The manager class shall live on the stack, and resources shall be allocated on the heap. This applies of course to smart points:"))),(0,r.kt)("p",null,"  \ud83d\udd25 ",(0,r.kt)("strong",{parentName:"p"},"Smart pointers shall be allocated on the stack, such that the scoping mechanism takes care of releasing resources")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Manager class should enacpsulate and abstract the handling of resources away from programmer.")),(0,r.kt)("p",null,"Example: simple manager class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class MyInt\n{\n    int *_p; // pointer to heap data\npublic:\n    MyInt(int *p = NULL) { _p = p; }\n    ~MyInt() \n    { \n        std::cout << "resource " << *_p << " deallocated" << std::endl;\n        delete _p; \n    }\n    int &operator*() { return *_p; } // // overload dereferencing operator\n};\n')),(0,r.kt)("h3",{id:"unique-pointer"},"Unique Pointer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <memory>\n#include <string>\n\nstruct Person {\n    Person(const std::string& first_name_, const std::string& last_name_,\n           double age_)\n        : first_name{first_name_}, last_name{last_name_}, age{age_} {}\n    std::string first_name;\n    std::string last_name;\n    double age;\n};\n\n\nvoid example_1() {\n    std::unique_ptr<int> unique(new int{5});\n    auto another = std::move(unique);\n    std::cout << *another << std::endl;\n}\n\nvoid example_2() {\n    auto num = std::make_unique<int>(5);\n    auto hassan = std::make_unique<Person>("Hassan", "Umari", 33);\n    std::cout << hassan->first_name << " " << hassan->last_name << std::endl;\n}\n')),(0,r.kt)("h3",{id:"shared-pointer"},"Shared Pointer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <memory>\n\nvoid example_1(){\n    std::shared_ptr<int> shared1(new int{5});\n    auto shared2 = shared1;\n}\n\nvoid example_2(){\n    auto shared_1 = std::make_shared<int>(5);\n    auto shared_2 = shared_1;\n}\n\nvoid example_3(){\n    auto shared_1 = std::make_shared<int>(5);\n    shared_1.reset(new int{10});\n}\n")),(0,r.kt)("h3",{id:"weak-pointer"},"Weak Pointer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <memory>\n#include <iostream>\n\nvoid example_1(){\n    std::shared_ptr<int> shared(new int{100});\n    std::weak_ptr<int> weak_1(shared);\n    std::cout << *weak_1.lock() << std::endl; // access using lock()\n    std::weak_ptr<int> weak_2(weak_1);\n}\n\nvoid example_2(){\n    std::shared_ptr<int> shared(new int);\n    std::weak_ptr<int> weak(shared);\n\n    shared.reset(new int);\n\n    if (weak.expired() == true)\n    {\n        std::cout << "Weak pointer expired!" << std::endl;\n    }\n\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"performance"},"Performance"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Always perfer to use unique pointer over shared."),(0,r.kt)("li",{parentName:"ul"},"always use ",(0,r.kt)("inlineCode",{parentName:"li"},"make_*()")," factory functions:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"They have slightky better performance."),(0,r.kt)("li",{parentName:"ul"},"Creation of smart pointer in a single step eliminating memory leak if resource constructor raises an error.")))),(0,r.kt)("h3",{id:"conversion-between-smart-pointers"},"Conversion between smart pointers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <memory>\n\nint main()\n{\n    // construct a unique pointer\n    std::unique_ptr<int> uniquePtr(new int);\n    \n    // (1) shared pointer from unique pointer\n    std::shared_ptr<int> sharedPtr1 = std::move(uniquePtr);\n\n    // (2) shared pointer from weak pointer\n    std::weak_ptr<int> weakPtr(sharedPtr1);\n    std::shared_ptr<int> sharedPtr2 = weakPtr.lock();\n\n    // (3) raw pointer from shared (or unique) pointer   \n    int *rawPtr = sharedPtr2.get();\n    delete rawPtr;\n\n    return 0;\n}\n")),(0,r.kt)("h3",{id:"transferring-ownership"},"Transferring Ownership"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <cstdio>\n#include <memory>\n#include <string>\n\nstruct Person {\n    Person(const std::string& name_, double age_) : age{age_}, name{name_} {}\n    std::string name;\n    double age;\n};\n\nstd::unique_ptr<Person> inspect_person(std::unique_ptr<Person> person) {\n    printf("Unique Person with name: %s, and age: %0.1f, is innocent\\n",\n           person->name.c_str(), person->age);\n    return person;\n}\n\nvoid inspect_person(std::shared_ptr<Person> person) {\n    printf("Shared Person with name: %s, and age: %0.1f, is innocent\\n",\n           person->name.c_str(), person->age);\n}\n\nvoid inspect_person_weak(std::weak_ptr<Person> person) {\n    printf("Weak Person with name: %s, and age: %0.1f, is innocent\\n",\n           person.lock()->name.c_str(), person.lock()->age);\n}\n\nvoid example_1() {\n    printf("Transferring unique ptr\\n");\n    auto person = std::make_unique<Person>("Hassan", 33);\n    person = inspect_person(std::move(person));\n\n    printf("\\n\\nTransferring shared ptr\\n");\n    std::shared_ptr<Person> shared = std::move(person);\n    inspect_person(shared);\n\n    printf("\\n\\nTransferring weak ptr\\n");\n    inspect_person_weak(shared);\n}\nint main() {\n    example_1();\n\n    return 0;\n}\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The following list contains all the variations (omitting ",(0,r.kt)("inlineCode",{parentName:"li"},"const"),") of passing an object to a function:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void f( object* );  // recommended passing objects\nvoid f( object& ); // recommended, no need to represent absence of object (nullptr)\nvoid f( unique_ptr<object> ); // object sink\nvoid f( unique_ptr<object>& ); // in and out unique ptr\nvoid f( shared_ptr<object> ); // shared ownership\nvoid f( shared_ptr<object>& ); // in and out shared ptr\n")),(0,r.kt)("h2",{id:"tips"},"Tips"),(0,r.kt)("h3",{id:"enable_shared_from_this"},"enable_shared_from_this"),(0,r.kt)("p",null,"Inherit from this template class to allow recovering a shared pointer from ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),". If an instance pointer is wrapper in a shared pointer, you cannot get a shared pointer from ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),". As this will create a new shared pointer that has different reference count.\nThe solution is to inherit from this template class, you can then use ",(0,r.kt)("inlineCode",{parentName:"p"},"shared_from_this()")," method to get a shared pointer from ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// enable_shared_from_this example\n#include <iostream>\n#include <memory>\n\nstruct C : std::enable_shared_from_this<C> { };\n\nint main () {\n  std::shared_ptr<C> foo, bar;\n\n  foo = std::make_shared<C>();\n\n  bar = foo->shared_from_this();\n\n  if (!foo.owner_before(bar) && !bar.owner_before(foo))\n    std::cout << "foo and bar share ownership";\n\n  return 0;\n}\n')))}d.isMDXComponent=!0}}]);